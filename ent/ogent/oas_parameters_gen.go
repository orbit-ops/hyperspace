// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DeleteApiKeyParams is parameters of deleteApiKey operation.
type DeleteApiKeyParams struct {
	// ID of the ApiKey.
	ID int
}

func unpackDeleteApiKeyParams(packed middleware.Parameters) (params DeleteApiKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeDeleteApiKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteApiKeyParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAuditParams is parameters of deleteAudit operation.
type DeleteAuditParams struct {
	// ID of the Audit.
	ID string
}

func unpackDeleteAuditParams(packed middleware.Parameters) (params DeleteAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteAuditParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAuditParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDeviceParams is parameters of deleteDevice operation.
type DeleteDeviceParams struct {
	// ID of the Device.
	ID uuid.UUID
}

func unpackDeleteDeviceParams(packed middleware.Parameters) (params DeleteDeviceParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeDeleteDeviceParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteDeviceParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteGroupParams is parameters of deleteGroup operation.
type DeleteGroupParams struct {
	// ID of the Group.
	ID string
}

func unpackDeleteGroupParams(packed middleware.Parameters) (params DeleteGroupParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteGroupParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteGroupParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteUserParams is parameters of deleteUser operation.
type DeleteUserParams struct {
	// ID of the User.
	ID string
}

func unpackDeleteUserParams(packed middleware.Parameters) (params DeleteUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteUserParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListApiKeyParams is parameters of listApiKey operation.
type ListApiKeyParams struct {
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
}

func unpackListApiKeyParams(packed middleware.Parameters) (params ListApiKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	return params
}

func decodeListApiKeyParams(args [0]string, argsEscaped bool, r *http.Request) (params ListApiKeyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XItemsPerPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           255,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAuditParams is parameters of listAudit operation.
type ListAuditParams struct {
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
	ID            OptString
	Action        OptString
	Author        OptString
}

func unpackListAuditParams(packed middleware.Parameters) (params ListAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "action",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Action = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "author",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Author = v.(OptString)
		}
	}
	return params
}

func decodeListAuditParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAuditParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XItemsPerPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           255,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ID.SetTo(paramsDotIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: action.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "action",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotActionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotActionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Action.SetTo(paramsDotActionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "action",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: author.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "author",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAuthorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAuthorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Author.SetTo(paramsDotAuthorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "author",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListDeviceParams is parameters of listDevice operation.
type ListDeviceParams struct {
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
	ID            OptString
	User          OptString
	Name          OptString
	Type          OptString
	Endpoint      OptString
	AllowedIps    OptString
	PublicKey     OptString
}

func unpackListDeviceParams(packed middleware.Parameters) (params ListDeviceParams) {
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "user",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.User = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endpoint",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Endpoint = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "allowed_ips",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AllowedIps = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "public_key",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PublicKey = v.(OptString)
		}
	}
	return params
}

func decodeListDeviceParams(args [0]string, argsEscaped bool, r *http.Request) (params ListDeviceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XItemsPerPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           255,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ID.SetTo(paramsDotIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: user.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.User.SetTo(paramsDotUserVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endpoint.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endpoint",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndpointVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEndpointVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Endpoint.SetTo(paramsDotEndpointVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endpoint",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: allowed_ips.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowed_ips",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowedIpsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAllowedIpsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowedIps.SetTo(paramsDotAllowedIpsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "allowed_ips",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: public_key.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "public_key",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPublicKeyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPublicKeyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PublicKey.SetTo(paramsDotPublicKeyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "public_key",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListGroupParams is parameters of listGroup operation.
type ListGroupParams struct {
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
	ID            OptString
	Name          OptString
	Scopes        OptString
	Cidr          OptString
}

func unpackListGroupParams(packed middleware.Parameters) (params ListGroupParams) {
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scopes",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scopes = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "cidr",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cidr = v.(OptString)
		}
	}
	return params
}

func decodeListGroupParams(args [0]string, argsEscaped bool, r *http.Request) (params ListGroupParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XItemsPerPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           255,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ID.SetTo(paramsDotIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: scopes.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scopes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScopesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotScopesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scopes.SetTo(paramsDotScopesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scopes",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: cidr.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cidr",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCidrVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCidrVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cidr.SetTo(paramsDotCidrVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cidr",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListGroupUsersParams is parameters of listGroupUsers operation.
type ListGroupUsersParams struct {
	// ID of the Group.
	ID string
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
}

func unpackListGroupUsersParams(packed middleware.Parameters) (params ListGroupUsersParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	return params
}

func decodeListGroupUsersParams(args [1]string, argsEscaped bool, r *http.Request) (params ListGroupUsersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListUserParams is parameters of listUser operation.
type ListUserParams struct {
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage  OptInt
	Sort           OptString
	ID             OptString
	Firstname      OptString
	Lastname       OptString
	Provider       OptString
	Email          OptString
	Disabled       OptString
	DisabledReason OptString
}

func unpackListUserParams(packed middleware.Parameters) (params ListUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ID = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "firstname",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Firstname = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "lastname",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Lastname = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "provider",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Provider = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "email",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Email = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "disabled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Disabled = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "disabled_reason",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DisabledReason = v.(OptString)
		}
	}
	return params
}

func decodeListUserParams(args [0]string, argsEscaped bool, r *http.Request) (params ListUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.XItemsPerPage.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           255,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ID.SetTo(paramsDotIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: firstname.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "firstname",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFirstnameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFirstnameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Firstname.SetTo(paramsDotFirstnameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "firstname",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: lastname.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lastname",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLastnameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLastnameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Lastname.SetTo(paramsDotLastnameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "lastname",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: provider.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "provider",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProviderVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProviderVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Provider.SetTo(paramsDotProviderVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "provider",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: email.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEmailVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEmailVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Email.SetTo(paramsDotEmailVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "email",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: disabled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "disabled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDisabledVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDisabledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Disabled.SetTo(paramsDotDisabledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "disabled",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: disabled_reason.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "disabled_reason",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDisabledReasonVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDisabledReasonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DisabledReason.SetTo(paramsDotDisabledReasonVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "disabled_reason",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListUserAuditParams is parameters of listUserAudit operation.
type ListUserAuditParams struct {
	// ID of the User.
	ID string
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
}

func unpackListUserAuditParams(packed middleware.Parameters) (params ListUserAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	return params
}

func decodeListUserAuditParams(args [1]string, argsEscaped bool, r *http.Request) (params ListUserAuditParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListUserDevicesParams is parameters of listUserDevices operation.
type ListUserDevicesParams struct {
	// ID of the User.
	ID string
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
}

func unpackListUserDevicesParams(packed middleware.Parameters) (params ListUserDevicesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	return params
}

func decodeListUserDevicesParams(args [1]string, argsEscaped bool, r *http.Request) (params ListUserDevicesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListUserKeysParams is parameters of listUserKeys operation.
type ListUserKeysParams struct {
	// ID of the User.
	ID string
	// What page to render.
	XPage OptInt
	// Item count to render per page.
	XItemsPerPage OptInt
	Sort          OptString
}

func unpackListUserKeysParams(packed middleware.Parameters) (params ListUserKeysParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "x-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "x-items-per-page",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.XItemsPerPage = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	return params
}

func decodeListUserKeysParams(args [1]string, argsEscaped bool, r *http.Request) (params ListUserKeysParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode header: x-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XPage.SetTo(paramsDotXPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode header: x-items-per-page.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-items-per-page",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotXItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.XItemsPerPage.SetTo(paramsDotXItemsPerPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "x-items-per-page",
			In:   "header",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ReadApiKeyParams is parameters of readApiKey operation.
type ReadApiKeyParams struct {
	// ID of the ApiKey.
	ID int
}

func unpackReadApiKeyParams(packed middleware.Parameters) (params ReadApiKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeReadApiKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadApiKeyParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadApiKeyUserParams is parameters of readApiKeyUser operation.
type ReadApiKeyUserParams struct {
	// ID of the ApiKey.
	ID int
}

func unpackReadApiKeyUserParams(packed middleware.Parameters) (params ReadApiKeyUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeReadApiKeyUserParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadApiKeyUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadAuditParams is parameters of readAudit operation.
type ReadAuditParams struct {
	// ID of the Audit.
	ID string
}

func unpackReadAuditParams(packed middleware.Parameters) (params ReadAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReadAuditParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadAuditParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadAuditUserParams is parameters of readAuditUser operation.
type ReadAuditUserParams struct {
	// ID of the Audit.
	ID string
}

func unpackReadAuditUserParams(packed middleware.Parameters) (params ReadAuditUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReadAuditUserParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadAuditUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadDeviceParams is parameters of readDevice operation.
type ReadDeviceParams struct {
	// ID of the Device.
	ID uuid.UUID
}

func unpackReadDeviceParams(packed middleware.Parameters) (params ReadDeviceParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeReadDeviceParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadDeviceParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadDeviceUserParams is parameters of readDeviceUser operation.
type ReadDeviceUserParams struct {
	// ID of the Device.
	ID uuid.UUID
}

func unpackReadDeviceUserParams(packed middleware.Parameters) (params ReadDeviceUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeReadDeviceUserParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadDeviceUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadGroupParams is parameters of readGroup operation.
type ReadGroupParams struct {
	// ID of the Group.
	ID string
}

func unpackReadGroupParams(packed middleware.Parameters) (params ReadGroupParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReadGroupParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadGroupParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadUserParams is parameters of readUser operation.
type ReadUserParams struct {
	// ID of the User.
	ID string
}

func unpackReadUserParams(packed middleware.Parameters) (params ReadUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReadUserParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReadUserGroupParams is parameters of readUserGroup operation.
type ReadUserGroupParams struct {
	// ID of the User.
	ID string
}

func unpackReadUserGroupParams(packed middleware.Parameters) (params ReadUserGroupParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReadUserGroupParams(args [1]string, argsEscaped bool, r *http.Request) (params ReadUserGroupParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateDeviceParams is parameters of updateDevice operation.
type UpdateDeviceParams struct {
	// ID of the Device.
	ID uuid.UUID
}

func unpackUpdateDeviceParams(packed middleware.Parameters) (params UpdateDeviceParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeUpdateDeviceParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateDeviceParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateGroupParams is parameters of updateGroup operation.
type UpdateGroupParams struct {
	// ID of the Group.
	ID string
}

func unpackUpdateGroupParams(packed middleware.Parameters) (params UpdateGroupParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateGroupParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateGroupParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateUserParams is parameters of updateUser operation.
type UpdateUserParams struct {
	// ID of the User.
	ID string
}

func unpackUpdateUserParams(packed middleware.Parameters) (params UpdateUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateUserParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
