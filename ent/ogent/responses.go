// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/tiagoposse/connect/ent"

func NewApiKeyCreate(e *ent.ApiKey) *ApiKeyCreate {
	if e == nil {
		return nil
	}
	var ret ApiKeyCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]ApiKeyCreateScopesItem{}).(*[]ApiKeyCreateScopesItem)
	ret.UserID = e.UserID
	return &ret
}

func NewApiKeyCreates(es []*ent.ApiKey) []ApiKeyCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ApiKeyCreate, len(es))
	for i, e := range es {
		r[i] = NewApiKeyCreate(e).Elem()
	}
	return r
}

func (ak *ApiKeyCreate) Elem() ApiKeyCreate {
	if ak == nil {
		return ApiKeyCreate{}
	}
	return *ak
}

func NewApiKeyList(e *ent.ApiKey) *ApiKeyList {
	if e == nil {
		return nil
	}
	var ret ApiKeyList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]ApiKeyListScopesItem{}).(*[]ApiKeyListScopesItem)
	ret.UserID = e.UserID
	return &ret
}

func NewApiKeyLists(es []*ent.ApiKey) []ApiKeyList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ApiKeyList, len(es))
	for i, e := range es {
		r[i] = NewApiKeyList(e).Elem()
	}
	return r
}

func (ak *ApiKeyList) Elem() ApiKeyList {
	if ak == nil {
		return ApiKeyList{}
	}
	return *ak
}

func NewApiKeyRead(e *ent.ApiKey) *ApiKeyRead {
	if e == nil {
		return nil
	}
	var ret ApiKeyRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]ApiKeyReadScopesItem{}).(*[]ApiKeyReadScopesItem)
	ret.UserID = e.UserID
	return &ret
}

func NewApiKeyReads(es []*ent.ApiKey) []ApiKeyRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ApiKeyRead, len(es))
	for i, e := range es {
		r[i] = NewApiKeyRead(e).Elem()
	}
	return r
}

func (ak *ApiKeyRead) Elem() ApiKeyRead {
	if ak == nil {
		return ApiKeyRead{}
	}
	return *ak
}

func NewApiKeyUserRead(e *ent.User) *ApiKeyUserRead {
	if e == nil {
		return nil
	}
	var ret ApiKeyUserRead
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewApiKeyUserReads(es []*ent.User) []ApiKeyUserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ApiKeyUserRead, len(es))
	for i, e := range es {
		r[i] = NewApiKeyUserRead(e).Elem()
	}
	return r
}

func (u *ApiKeyUserRead) Elem() ApiKeyUserRead {
	if u == nil {
		return ApiKeyUserRead{}
	}
	return *u
}

func NewAuditList(e *ent.Audit) *AuditList {
	if e == nil {
		return nil
	}
	var ret AuditList
	ret.ID = e.ID
	ret.Action = e.Action
	ret.Author = e.Author
	return &ret
}

func NewAuditLists(es []*ent.Audit) []AuditList {
	if len(es) == 0 {
		return nil
	}
	r := make([]AuditList, len(es))
	for i, e := range es {
		r[i] = NewAuditList(e).Elem()
	}
	return r
}

func (a *AuditList) Elem() AuditList {
	if a == nil {
		return AuditList{}
	}
	return *a
}

func NewAuditRead(e *ent.Audit) *AuditRead {
	if e == nil {
		return nil
	}
	var ret AuditRead
	ret.ID = e.ID
	ret.Action = e.Action
	ret.Author = e.Author
	return &ret
}

func NewAuditReads(es []*ent.Audit) []AuditRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]AuditRead, len(es))
	for i, e := range es {
		r[i] = NewAuditRead(e).Elem()
	}
	return r
}

func (a *AuditRead) Elem() AuditRead {
	if a == nil {
		return AuditRead{}
	}
	return *a
}

func NewAuditUserRead(e *ent.User) *AuditUserRead {
	if e == nil {
		return nil
	}
	var ret AuditUserRead
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewAuditUserReads(es []*ent.User) []AuditUserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]AuditUserRead, len(es))
	for i, e := range es {
		r[i] = NewAuditUserRead(e).Elem()
	}
	return r
}

func (u *AuditUserRead) Elem() AuditUserRead {
	if u == nil {
		return AuditUserRead{}
	}
	return *u
}

func NewDeviceCreate(e *ent.Device) *DeviceCreate {
	if e == nil {
		return nil
	}
	var ret DeviceCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.Type = e.Type
	ret.DNS = *JsonConvert(e.DNS, &[]string{}).(*[]string)
	ret.PublicKey = e.PublicKey
	ret.PresharedKey = e.PresharedKey
	ret.KeepAlive = e.KeepAlive
	ret.Endpoint = e.Endpoint.String()
	ret.AllowedIps = *JsonConvert(e.AllowedIps, &[]string{}).(*[]string)
	ret.UserID = e.UserID
	return &ret
}

func NewDeviceCreates(es []*ent.Device) []DeviceCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DeviceCreate, len(es))
	for i, e := range es {
		r[i] = NewDeviceCreate(e).Elem()
	}
	return r
}

func (d *DeviceCreate) Elem() DeviceCreate {
	if d == nil {
		return DeviceCreate{}
	}
	return *d
}

func NewDeviceList(e *ent.Device) *DeviceList {
	if e == nil {
		return nil
	}
	var ret DeviceList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.Type = e.Type
	ret.DNS = *JsonConvert(e.DNS, &[]string{}).(*[]string)
	ret.PublicKey = e.PublicKey
	ret.KeepAlive = e.KeepAlive
	ret.Endpoint = e.Endpoint.String()
	ret.AllowedIps = *JsonConvert(e.AllowedIps, &[]string{}).(*[]string)
	ret.UserID = e.UserID
	return &ret
}

func NewDeviceLists(es []*ent.Device) []DeviceList {
	if len(es) == 0 {
		return nil
	}
	r := make([]DeviceList, len(es))
	for i, e := range es {
		r[i] = NewDeviceList(e).Elem()
	}
	return r
}

func (d *DeviceList) Elem() DeviceList {
	if d == nil {
		return DeviceList{}
	}
	return *d
}

func NewDeviceRead(e *ent.Device) *DeviceRead {
	if e == nil {
		return nil
	}
	var ret DeviceRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.Type = e.Type
	ret.DNS = *JsonConvert(e.DNS, &[]string{}).(*[]string)
	ret.PublicKey = e.PublicKey
	ret.KeepAlive = e.KeepAlive
	ret.Endpoint = e.Endpoint.String()
	ret.AllowedIps = *JsonConvert(e.AllowedIps, &[]string{}).(*[]string)
	ret.UserID = e.UserID
	return &ret
}

func NewDeviceReads(es []*ent.Device) []DeviceRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]DeviceRead, len(es))
	for i, e := range es {
		r[i] = NewDeviceRead(e).Elem()
	}
	return r
}

func (d *DeviceRead) Elem() DeviceRead {
	if d == nil {
		return DeviceRead{}
	}
	return *d
}

func NewDeviceUpdate(e *ent.Device) *DeviceUpdate {
	if e == nil {
		return nil
	}
	var ret DeviceUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.Type = e.Type
	ret.DNS = *JsonConvert(e.DNS, &[]string{}).(*[]string)
	ret.PublicKey = e.PublicKey
	ret.KeepAlive = e.KeepAlive
	ret.Endpoint = e.Endpoint.String()
	ret.AllowedIps = *JsonConvert(e.AllowedIps, &[]string{}).(*[]string)
	ret.UserID = e.UserID
	return &ret
}

func NewDeviceUpdates(es []*ent.Device) []DeviceUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DeviceUpdate, len(es))
	for i, e := range es {
		r[i] = NewDeviceUpdate(e).Elem()
	}
	return r
}

func (d *DeviceUpdate) Elem() DeviceUpdate {
	if d == nil {
		return DeviceUpdate{}
	}
	return *d
}

func NewDeviceUserRead(e *ent.User) *DeviceUserRead {
	if e == nil {
		return nil
	}
	var ret DeviceUserRead
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewDeviceUserReads(es []*ent.User) []DeviceUserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]DeviceUserRead, len(es))
	for i, e := range es {
		r[i] = NewDeviceUserRead(e).Elem()
	}
	return r
}

func (u *DeviceUserRead) Elem() DeviceUserRead {
	if u == nil {
		return DeviceUserRead{}
	}
	return *u
}

func NewGroupCreate(e *ent.Group) *GroupCreate {
	if e == nil {
		return nil
	}
	var ret GroupCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]GroupCreateScopesItem{}).(*[]GroupCreateScopesItem)
	ret.Cidr = e.Cidr.String()
	ret.Rules = *JsonConvert(e.Rules, &[]GroupCreateRulesItem{}).(*[]GroupCreateRulesItem)
	return &ret
}

func NewGroupCreates(es []*ent.Group) []GroupCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupCreate, len(es))
	for i, e := range es {
		r[i] = NewGroupCreate(e).Elem()
	}
	return r
}

func (gr *GroupCreate) Elem() GroupCreate {
	if gr == nil {
		return GroupCreate{}
	}
	return *gr
}

func NewGroupList(e *ent.Group) *GroupList {
	if e == nil {
		return nil
	}
	var ret GroupList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]GroupListScopesItem{}).(*[]GroupListScopesItem)
	ret.Cidr = e.Cidr.String()
	ret.Rules = *JsonConvert(e.Rules, &[]GroupListRulesItem{}).(*[]GroupListRulesItem)
	return &ret
}

func NewGroupLists(es []*ent.Group) []GroupList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupList, len(es))
	for i, e := range es {
		r[i] = NewGroupList(e).Elem()
	}
	return r
}

func (gr *GroupList) Elem() GroupList {
	if gr == nil {
		return GroupList{}
	}
	return *gr
}

func NewGroupRead(e *ent.Group) *GroupRead {
	if e == nil {
		return nil
	}
	var ret GroupRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]GroupReadScopesItem{}).(*[]GroupReadScopesItem)
	ret.Cidr = e.Cidr.String()
	ret.Rules = *JsonConvert(e.Rules, &[]GroupReadRulesItem{}).(*[]GroupReadRulesItem)
	return &ret
}

func NewGroupReads(es []*ent.Group) []GroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupRead, len(es))
	for i, e := range es {
		r[i] = NewGroupRead(e).Elem()
	}
	return r
}

func (gr *GroupRead) Elem() GroupRead {
	if gr == nil {
		return GroupRead{}
	}
	return *gr
}

func NewGroupUpdate(e *ent.Group) *GroupUpdate {
	if e == nil {
		return nil
	}
	var ret GroupUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]GroupUpdateScopesItem{}).(*[]GroupUpdateScopesItem)
	ret.Cidr = e.Cidr.String()
	ret.Rules = *JsonConvert(e.Rules, &[]GroupUpdateRulesItem{}).(*[]GroupUpdateRulesItem)
	return &ret
}

func NewGroupUpdates(es []*ent.Group) []GroupUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUpdate, len(es))
	for i, e := range es {
		r[i] = NewGroupUpdate(e).Elem()
	}
	return r
}

func (gr *GroupUpdate) Elem() GroupUpdate {
	if gr == nil {
		return GroupUpdate{}
	}
	return *gr
}

func NewGroupUsersList(e *ent.User) *GroupUsersList {
	if e == nil {
		return nil
	}
	var ret GroupUsersList
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewGroupUsersLists(es []*ent.User) []GroupUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUsersList, len(es))
	for i, e := range es {
		r[i] = NewGroupUsersList(e).Elem()
	}
	return r
}

func (u *GroupUsersList) Elem() GroupUsersList {
	if u == nil {
		return GroupUsersList{}
	}
	return *u
}

func NewUserCreate(e *ent.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewUserCreates(es []*ent.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *ent.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewUserLists(es []*ent.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *ent.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewUserReads(es []*ent.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *ent.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.Email = e.Email
	ret.Firstname = e.Firstname
	ret.Lastname = e.Lastname
	ret.Provider = e.Provider
	ret.PhotoURL = NewOptString(e.PhotoURL)
	ret.Disabled = e.Disabled
	ret.DisabledReason = NewOptString(e.DisabledReason)
	ret.GroupID = e.GroupID
	return &ret
}

func NewUserUpdates(es []*ent.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserAuditList(e *ent.Audit) *UserAuditList {
	if e == nil {
		return nil
	}
	var ret UserAuditList
	ret.ID = e.ID
	ret.Action = e.Action
	ret.Author = e.Author
	return &ret
}

func NewUserAuditLists(es []*ent.Audit) []UserAuditList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserAuditList, len(es))
	for i, e := range es {
		r[i] = NewUserAuditList(e).Elem()
	}
	return r
}

func (a *UserAuditList) Elem() UserAuditList {
	if a == nil {
		return UserAuditList{}
	}
	return *a
}

func NewUserDevicesList(e *ent.Device) *UserDevicesList {
	if e == nil {
		return nil
	}
	var ret UserDevicesList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.Type = e.Type
	ret.DNS = *JsonConvert(e.DNS, &[]string{}).(*[]string)
	ret.PublicKey = e.PublicKey
	ret.PresharedKey = e.PresharedKey
	ret.KeepAlive = e.KeepAlive
	ret.Endpoint = e.Endpoint.String()
	ret.AllowedIps = *JsonConvert(e.AllowedIps, &[]string{}).(*[]string)
	ret.UserID = e.UserID
	return &ret
}

func NewUserDevicesLists(es []*ent.Device) []UserDevicesList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserDevicesList, len(es))
	for i, e := range es {
		r[i] = NewUserDevicesList(e).Elem()
	}
	return r
}

func (d *UserDevicesList) Elem() UserDevicesList {
	if d == nil {
		return UserDevicesList{}
	}
	return *d
}

func NewUserGroupRead(e *ent.Group) *UserGroupRead {
	if e == nil {
		return nil
	}
	var ret UserGroupRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]UserGroupReadScopesItem{}).(*[]UserGroupReadScopesItem)
	ret.Cidr = e.Cidr.String()
	ret.Rules = *JsonConvert(e.Rules, &[]UserGroupReadRulesItem{}).(*[]UserGroupReadRulesItem)
	return &ret
}

func NewUserGroupReads(es []*ent.Group) []UserGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserGroupRead, len(es))
	for i, e := range es {
		r[i] = NewUserGroupRead(e).Elem()
	}
	return r
}

func (gr *UserGroupRead) Elem() UserGroupRead {
	if gr == nil {
		return UserGroupRead{}
	}
	return *gr
}

func NewUserKeysList(e *ent.ApiKey) *UserKeysList {
	if e == nil {
		return nil
	}
	var ret UserKeysList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Scopes = *JsonConvert(e.Scopes, &[]UserKeysListScopesItem{}).(*[]UserKeysListScopesItem)
	ret.UserID = e.UserID
	return &ret
}

func NewUserKeysLists(es []*ent.ApiKey) []UserKeysList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserKeysList, len(es))
	for i, e := range es {
		r[i] = NewUserKeysList(e).Elem()
	}
	return r
}

func (ak *UserKeysList) Elem() UserKeysList {
	if ak == nil {
		return UserKeysList{}
	}
	return *ak
}
