// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/tiagoposse/connect/ent/apikey"
	"github.com/tiagoposse/connect/ent/audit"
	"github.com/tiagoposse/connect/ent/device"
	"github.com/tiagoposse/connect/ent/group"
	"github.com/tiagoposse/connect/ent/user"
	"github.com/tiagoposse/connect/internal/types"
	"github.com/tiagoposse/go-auth/controller"

	"github.com/tiagoposse/connect/ent"
)

type OgentHandlerWiring struct {
	CreateApiKeyWire func(ctx context.Context, e *ent.ApiKeyCreate, req *CreateApiKeyReq) error
	DeleteApiKeyWire func(ctx context.Context, params DeleteApiKeyParams) error
	ListApiKeyWire   func(ctx context.Context, es []*ent.ApiKey, params ListApiKeyParams) error
	ReadApiKeyWire   func(ctx context.Context, e *ent.ApiKey, params ReadApiKeyParams) error

	DeleteAuditWire func(ctx context.Context, params DeleteAuditParams) error
	ListAuditWire   func(ctx context.Context, es []*ent.Audit, params ListAuditParams) error
	ReadAuditWire   func(ctx context.Context, e *ent.Audit, params ReadAuditParams) error

	CreateDeviceWire func(ctx context.Context, e *ent.DeviceCreate, req *CreateDeviceReq) error
	DeleteDeviceWire func(ctx context.Context, params DeleteDeviceParams) error
	ListDeviceWire   func(ctx context.Context, es []*ent.Device, params ListDeviceParams) error
	ReadDeviceWire   func(ctx context.Context, e *ent.Device, params ReadDeviceParams) error
	UpdateDeviceWire func(ctx context.Context, e *ent.DeviceUpdateOne, req *UpdateDeviceReq, params UpdateDeviceParams) error

	CreateGroupWire func(ctx context.Context, e *ent.GroupCreate, req *CreateGroupReq) error
	ReadGroupWire   func(ctx context.Context, e *ent.Group, params ReadGroupParams) error
	UpdateGroupWire func(ctx context.Context, e *ent.GroupUpdateOne, req *UpdateGroupReq, params UpdateGroupParams) error
	DeleteGroupWire func(ctx context.Context, params DeleteGroupParams) error
	ListGroupWire   func(ctx context.Context, es []*ent.Group, params ListGroupParams) error

	CreateUserWire func(ctx context.Context, e *ent.UserCreate, req *CreateUserReq) error
	DeleteUserWire func(ctx context.Context, params DeleteUserParams) error
	ListUserWire   func(ctx context.Context, es []*ent.User, params ListUserParams) error
	ReadUserWire   func(ctx context.Context, e *ent.User, params ReadUserParams) error
	UpdateUserWire func(ctx context.Context, e *ent.UserUpdateOne, req *UpdateUserReq, params UpdateUserParams) error
}

func newOgentHandlerWiring() *OgentHandlerWiring {
	return &OgentHandlerWiring{CreateApiKeyWire: func(ctx context.Context, e *ent.ApiKeyCreate, req *CreateApiKeyReq) error { return nil },
		DeleteApiKeyWire: func(ctx context.Context, params DeleteApiKeyParams) error { return nil },
		ListApiKeyWire:   func(ctx context.Context, es []*ent.ApiKey, params ListApiKeyParams) error { return nil },
		ReadApiKeyWire:   func(ctx context.Context, e *ent.ApiKey, params ReadApiKeyParams) error { return nil },

		DeleteAuditWire: func(ctx context.Context, params DeleteAuditParams) error { return nil },
		ListAuditWire:   func(ctx context.Context, es []*ent.Audit, params ListAuditParams) error { return nil },
		ReadAuditWire:   func(ctx context.Context, e *ent.Audit, params ReadAuditParams) error { return nil },

		CreateDeviceWire: func(ctx context.Context, e *ent.DeviceCreate, req *CreateDeviceReq) error { return nil },
		DeleteDeviceWire: func(ctx context.Context, params DeleteDeviceParams) error { return nil },
		ListDeviceWire:   func(ctx context.Context, es []*ent.Device, params ListDeviceParams) error { return nil },
		ReadDeviceWire:   func(ctx context.Context, e *ent.Device, params ReadDeviceParams) error { return nil },
		UpdateDeviceWire: func(ctx context.Context, e *ent.DeviceUpdateOne, req *UpdateDeviceReq, params UpdateDeviceParams) error {
			return nil
		},

		CreateGroupWire: func(ctx context.Context, e *ent.GroupCreate, req *CreateGroupReq) error { return nil },
		ReadGroupWire:   func(ctx context.Context, e *ent.Group, params ReadGroupParams) error { return nil },
		UpdateGroupWire: func(ctx context.Context, e *ent.GroupUpdateOne, req *UpdateGroupReq, params UpdateGroupParams) error {
			return nil
		},
		DeleteGroupWire: func(ctx context.Context, params DeleteGroupParams) error { return nil },
		ListGroupWire:   func(ctx context.Context, es []*ent.Group, params ListGroupParams) error { return nil },

		CreateUserWire: func(ctx context.Context, e *ent.UserCreate, req *CreateUserReq) error { return nil },
		DeleteUserWire: func(ctx context.Context, params DeleteUserParams) error { return nil },
		ListUserWire:   func(ctx context.Context, es []*ent.User, params ListUserParams) error { return nil },
		ReadUserWire:   func(ctx context.Context, e *ent.User, params ReadUserParams) error { return nil },
		UpdateUserWire: func(ctx context.Context, e *ent.UserUpdateOne, req *UpdateUserReq, params UpdateUserParams) error {
			return nil
		},
	}
}

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
	wires  *OgentHandlerWiring
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler {
	return &OgentHandler{client: c, wires: newOgentHandlerWiring()}
}

func (h *OgentHandler) SetWiring(wires *OgentHandlerWiring) {
	if wires.CreateApiKeyWire != nil {
		h.wires.CreateApiKeyWire = wires.CreateApiKeyWire
	}

	if wires.DeleteApiKeyWire != nil {
		h.wires.DeleteApiKeyWire = wires.DeleteApiKeyWire
	}

	if wires.ListApiKeyWire != nil {
		h.wires.ListApiKeyWire = wires.ListApiKeyWire
	}

	if wires.ReadApiKeyWire != nil {
		h.wires.ReadApiKeyWire = wires.ReadApiKeyWire
	}

	if wires.DeleteAuditWire != nil {
		h.wires.DeleteAuditWire = wires.DeleteAuditWire
	}

	if wires.ListAuditWire != nil {
		h.wires.ListAuditWire = wires.ListAuditWire
	}

	if wires.ReadAuditWire != nil {
		h.wires.ReadAuditWire = wires.ReadAuditWire
	}

	if wires.CreateDeviceWire != nil {
		h.wires.CreateDeviceWire = wires.CreateDeviceWire
	}

	if wires.DeleteDeviceWire != nil {
		h.wires.DeleteDeviceWire = wires.DeleteDeviceWire
	}

	if wires.ListDeviceWire != nil {
		h.wires.ListDeviceWire = wires.ListDeviceWire
	}

	if wires.ReadDeviceWire != nil {
		h.wires.ReadDeviceWire = wires.ReadDeviceWire
	}

	if wires.UpdateDeviceWire != nil {
		h.wires.UpdateDeviceWire = wires.UpdateDeviceWire
	}

	if wires.CreateGroupWire != nil {
		h.wires.CreateGroupWire = wires.CreateGroupWire
	}

	if wires.ReadGroupWire != nil {
		h.wires.ReadGroupWire = wires.ReadGroupWire
	}

	if wires.UpdateGroupWire != nil {
		h.wires.UpdateGroupWire = wires.UpdateGroupWire
	}

	if wires.DeleteGroupWire != nil {
		h.wires.DeleteGroupWire = wires.DeleteGroupWire
	}

	if wires.ListGroupWire != nil {
		h.wires.ListGroupWire = wires.ListGroupWire
	}

	if wires.CreateUserWire != nil {
		h.wires.CreateUserWire = wires.CreateUserWire
	}

	if wires.DeleteUserWire != nil {
		h.wires.DeleteUserWire = wires.DeleteUserWire
	}

	if wires.ListUserWire != nil {
		h.wires.ListUserWire = wires.ListUserWire
	}

	if wires.ReadUserWire != nil {
		h.wires.ReadUserWire = wires.ReadUserWire
	}

	if wires.UpdateUserWire != nil {
		h.wires.UpdateUserWire = wires.UpdateUserWire
	}

}

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

func JsonConvert(from interface{}, to interface{}) interface{} {
	bs, err := json.Marshal(from)
	if err != nil {
		panic(err)
	}

	if err := json.Unmarshal(bs, to); err != nil {
		panic(err)
	}

	return to
}

// CreateApiKey handles POST /api-keys requests.
func (h *OgentHandler) CreateApiKey(ctx context.Context, req *CreateApiKeyReq) (CreateApiKeyRes, error) {
	b := h.client.ApiKey.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetKey(req.Key)
	b.SetScopes(JsonConvert(req.Scopes, controller.Scopes{}).(controller.Scopes))
	// Add all edges.
	b.SetUserID(req.User)
	// Add Wiring
	if err := h.wires.CreateApiKeyWire(ctx, b, req); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ApiKey.Query().Where(apikey.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApiKeyCreate(e), nil
}

// DeleteApiKey handles DELETE /api-keys/{id} requests.
func (h *OgentHandler) DeleteApiKey(ctx context.Context, params DeleteApiKeyParams) (DeleteApiKeyRes, error) {
	// Add Wiring
	if err := h.wires.DeleteApiKeyWire(ctx, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	err := h.client.ApiKey.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteApiKeyNoContent), nil

}

// ListApiKey handles GET /api-keys requests.
func (h *OgentHandler) ListApiKey(ctx context.Context, params ListApiKeyParams) (ListApiKeyRes, error) {
	q := h.client.ApiKey.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ListApiKeyWire(ctx, es, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	r := NewApiKeyLists(es)
	return (*ListApiKeyOKApplicationJSON)(&r), nil
}

// ReadApiKey handles GET /api-keys/{id} requests.
func (h *OgentHandler) ReadApiKey(ctx context.Context, params ReadApiKeyParams) (ReadApiKeyRes, error) {
	q := h.client.ApiKey.Query().Where(apikey.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ReadApiKeyWire(ctx, e, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	return NewApiKeyRead(e), nil
}

// ReadApiKeyUser handles GET /api-keys/{id}/user requests.
func (h *OgentHandler) ReadApiKeyUser(ctx context.Context, params ReadApiKeyUserParams) (ReadApiKeyUserRes, error) {
	q := h.client.ApiKey.Query().Where(apikey.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewApiKeyUserRead(e), nil
}

// DeleteAudit handles DELETE /audits/{id} requests.
func (h *OgentHandler) DeleteAudit(ctx context.Context, params DeleteAuditParams) (DeleteAuditRes, error) {
	// Add Wiring
	if err := h.wires.DeleteAuditWire(ctx, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	err := h.client.Audit.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteAuditNoContent), nil

}

// ListAudit handles GET /audits requests.
func (h *OgentHandler) ListAudit(ctx context.Context, params ListAuditParams) (ListAuditRes, error) {
	q := h.client.Audit.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ListAuditWire(ctx, es, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	r := NewAuditLists(es)
	return (*ListAuditOKApplicationJSON)(&r), nil
}

// ReadAudit handles GET /audits/{id} requests.
func (h *OgentHandler) ReadAudit(ctx context.Context, params ReadAuditParams) (ReadAuditRes, error) {
	q := h.client.Audit.Query().Where(audit.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ReadAuditWire(ctx, e, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	return NewAuditRead(e), nil
}

// ReadAuditUser handles GET /audits/{id}/user requests.
func (h *OgentHandler) ReadAuditUser(ctx context.Context, params ReadAuditUserParams) (ReadAuditUserRes, error) {
	q := h.client.Audit.Query().Where(audit.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAuditUserRead(e), nil
}

// CreateDevice handles POST /devices requests.
func (h *OgentHandler) CreateDevice(ctx context.Context, req *CreateDeviceReq) (CreateDeviceRes, error) {
	b := h.client.Device.Create()
	// Add all fields.
	b.SetName(req.Name)
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	b.SetType(req.Type)
	b.SetPublicKey(req.PublicKey)
	// Add all edges.
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Add Wiring
	if err := h.wires.CreateDeviceWire(ctx, b, req); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Device.Query().Where(device.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDeviceCreate(e), nil
}

// DeleteDevice handles DELETE /devices/{id} requests.
func (h *OgentHandler) DeleteDevice(ctx context.Context, params DeleteDeviceParams) (DeleteDeviceRes, error) {
	// Add Wiring
	if err := h.wires.DeleteDeviceWire(ctx, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	err := h.client.Device.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteDeviceNoContent), nil

}

// ListDevice handles GET /devices requests.
func (h *OgentHandler) ListDevice(ctx context.Context, params ListDeviceParams) (ListDeviceRes, error) {
	q := h.client.Device.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ListDeviceWire(ctx, es, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	r := NewDeviceLists(es)
	return (*ListDeviceOKApplicationJSON)(&r), nil
}

// ReadDevice handles GET /devices/{id} requests.
func (h *OgentHandler) ReadDevice(ctx context.Context, params ReadDeviceParams) (ReadDeviceRes, error) {
	q := h.client.Device.Query().Where(device.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ReadDeviceWire(ctx, e, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	return NewDeviceRead(e), nil
}

// UpdateDevice handles PATCH /devices/{id} requests.
func (h *OgentHandler) UpdateDevice(ctx context.Context, req *UpdateDeviceReq, params UpdateDeviceParams) (UpdateDeviceRes, error) {
	b := h.client.Device.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetType(v)
	}
	if req.DNS != nil {
		v := req.DNS
		b.SetDNS(JsonConvert(v, []string{}).([]string))
	}
	if v, ok := req.Endpoint.Get(); ok {
		b.SetEndpoint(types.Inet{}.ParseString(v))
	}
	if v, ok := req.AllowedIps.Get(); ok {
		b.SetAllowedIps(v)
	}
	// Add all edges.
	// Add Wiring
	if err := h.wires.UpdateDeviceWire(ctx, b, req, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Device.Query().Where(device.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDeviceUpdate(e), nil
}

// ReadDeviceUser handles GET /devices/{id}/user requests.
func (h *OgentHandler) ReadDeviceUser(ctx context.Context, params ReadDeviceUserParams) (ReadDeviceUserRes, error) {
	q := h.client.Device.Query().Where(device.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewDeviceUserRead(e), nil
}

// CreateGroup handles POST /groups requests.
func (h *OgentHandler) CreateGroup(ctx context.Context, req *CreateGroupReq) (CreateGroupRes, error) {
	b := h.client.Group.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetScopes(JsonConvert(req.Scopes, controller.Scopes{}).(controller.Scopes))
	b.SetCidr(types.Cidr{}.ParseString(req.Cidr))
	b.SetRules(JsonConvert(req.Rules, []types.Rule{}).([]types.Rule))
	// Add all edges.
	b.AddUserIDs(req.Users...)
	// Add Wiring
	if err := h.wires.CreateGroupWire(ctx, b, req); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupCreate(e), nil
}

// ReadGroup handles GET /groups/{id} requests.
func (h *OgentHandler) ReadGroup(ctx context.Context, params ReadGroupParams) (ReadGroupRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ReadGroupWire(ctx, e, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	return NewGroupRead(e), nil
}

// UpdateGroup handles PATCH /groups/{id} requests.
func (h *OgentHandler) UpdateGroup(ctx context.Context, req *UpdateGroupReq, params UpdateGroupParams) (UpdateGroupRes, error) {
	b := h.client.Group.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if req.Scopes != nil {
		v := req.Scopes
		b.SetScopes(JsonConvert(v, controller.Scopes{}).(controller.Scopes))
	}
	if v, ok := req.Cidr.Get(); ok {
		b.SetCidr(types.Cidr{}.ParseString(v))
	}
	if req.Rules != nil {
		v := req.Rules
		b.SetRules(JsonConvert(v, []types.Rule{}).([]types.Rule))
	}
	// Add all edges.
	if req.Users != nil {
		b.ClearUsers().AddUserIDs(req.Users...)
	}
	// Add Wiring
	if err := h.wires.UpdateGroupWire(ctx, b, req, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupUpdate(e), nil
}

// DeleteGroup handles DELETE /groups/{id} requests.
func (h *OgentHandler) DeleteGroup(ctx context.Context, params DeleteGroupParams) (DeleteGroupRes, error) {
	// Add Wiring
	if err := h.wires.DeleteGroupWire(ctx, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	err := h.client.Group.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGroupNoContent), nil

}

// ListGroup handles GET /groups requests.
func (h *OgentHandler) ListGroup(ctx context.Context, params ListGroupParams) (ListGroupRes, error) {
	q := h.client.Group.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ListGroupWire(ctx, es, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	r := NewGroupLists(es)
	return (*ListGroupOKApplicationJSON)(&r), nil
}

// ListGroupUsers handles GET /groups/{id}/users requests.
func (h *OgentHandler) ListGroupUsers(ctx context.Context, params ListGroupUsersParams) (ListGroupUsersRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupUsersLists(es)
	return (*ListGroupUsersOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req *CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetEmail(req.Email)
	b.SetFirstname(req.Firstname)
	b.SetLastname(req.Lastname)
	b.SetProvider(req.Provider)
	if v, ok := req.Password.Get(); ok {
		b.SetPassword(v)
	}
	if v, ok := req.Salt.Get(); ok {
		b.SetSalt(v)
	}
	if v, ok := req.PhotoURL.Get(); ok {
		b.SetPhotoURL(v)
	}
	b.SetDisabled(req.Disabled)
	if v, ok := req.DisabledReason.Get(); ok {
		b.SetDisabledReason(v)
	}
	// Add all edges.
	b.SetGroupID(req.Group)
	b.AddDeviceIDs(req.Devices...)
	b.AddKeyIDs(req.Keys...)
	b.AddAuditIDs(req.Audit...)
	// Add Wiring
	if err := h.wires.CreateUserWire(ctx, b, req); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	// Add Wiring
	if err := h.wires.DeleteUserWire(ctx, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ListUserWire(ctx, es, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Add Wiring
	if err := h.wires.ReadUserWire(ctx, e, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Firstname.Get(); ok {
		b.SetFirstname(v)
	}
	if v, ok := req.Lastname.Get(); ok {
		b.SetLastname(v)
	}
	if v, ok := req.Password.Get(); ok {
		b.SetPassword(v)
	}
	if v, ok := req.Salt.Get(); ok {
		b.SetSalt(v)
	}
	if v, ok := req.PhotoURL.Get(); ok {
		b.SetPhotoURL(v)
	}
	if v, ok := req.Disabled.Get(); ok {
		b.SetDisabled(v)
	}
	if v, ok := req.DisabledReason.Get(); ok {
		b.SetDisabledReason(v)
	}
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	if req.Devices != nil {
		b.ClearDevices().AddDeviceIDs(req.Devices...)
	}
	if req.Keys != nil {
		b.ClearKeys().AddKeyIDs(req.Keys...)
	}
	if req.Audit != nil {
		b.ClearAudit().AddAuditIDs(req.Audit...)
	}
	// Add Wiring
	if err := h.wires.UpdateUserWire(ctx, b, req, params); err != nil {
		return &R500{
			Code:   http.StatusInternalServerError,
			Status: http.StatusText(http.StatusConflict),
			Errors: rawError(err),
		}, nil
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// ReadUserGroup handles GET /users/{id}/group requests.
func (h *OgentHandler) ReadUserGroup(ctx context.Context, params ReadUserGroupParams) (ReadUserGroupRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserGroupRead(e), nil
}

// ListUserDevices handles GET /users/{id}/devices requests.
func (h *OgentHandler) ListUserDevices(ctx context.Context, params ListUserDevicesParams) (ListUserDevicesRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryDevices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserDevicesLists(es)
	return (*ListUserDevicesOKApplicationJSON)(&r), nil
}

// ListUserKeys handles GET /users/{id}/keys requests.
func (h *OgentHandler) ListUserKeys(ctx context.Context, params ListUserKeysParams) (ListUserKeysRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryKeys()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserKeysLists(es)
	return (*ListUserKeysOKApplicationJSON)(&r), nil
}

// ListUserAudit handles GET /users/{id}/audit requests.
func (h *OgentHandler) ListUserAudit(ctx context.Context, params ListUserAuditParams) (ListUserAuditRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryAudit()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserAuditLists(es)
	return (*ListUserAuditOKApplicationJSON)(&r), nil
}
