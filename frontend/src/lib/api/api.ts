/* tslint:disable */
/* eslint-disable */
/**
 * Ent Schema API
 * This is an auto generated API description made out of an Ent schema definition
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKey
     */
    'scopes': Array<ApiKeyScopesEnum>;
    /**
     * 
     * @type {User}
     * @memberof ApiKey
     */
    'user': User;
}

export const ApiKeyScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type ApiKeyScopesEnum = typeof ApiKeyScopesEnum[keyof typeof ApiKeyScopesEnum];

/**
 * 
 * @export
 * @interface ApiKeyCreate
 */
export interface ApiKeyCreate {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyCreate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyCreate
     */
    'scopes': Array<ApiKeyCreateScopesEnum>;
}

export const ApiKeyCreateScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type ApiKeyCreateScopesEnum = typeof ApiKeyCreateScopesEnum[keyof typeof ApiKeyCreateScopesEnum];

/**
 * 
 * @export
 * @interface ApiKeyList
 */
export interface ApiKeyList {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyList
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyList
     */
    'scopes': Array<ApiKeyListScopesEnum>;
}

export const ApiKeyListScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type ApiKeyListScopesEnum = typeof ApiKeyListScopesEnum[keyof typeof ApiKeyListScopesEnum];

/**
 * 
 * @export
 * @interface ApiKeyRead
 */
export interface ApiKeyRead {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyRead
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRead
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKeyRead
     */
    'scopes': Array<ApiKeyReadScopesEnum>;
}

export const ApiKeyReadScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type ApiKeyReadScopesEnum = typeof ApiKeyReadScopesEnum[keyof typeof ApiKeyReadScopesEnum];

/**
 * 
 * @export
 * @interface ApiKeyUserRead
 */
export interface ApiKeyUserRead {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyUserRead
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUserRead
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface Audit
 */
export interface Audit {
    /**
     * 
     * @type {string}
     * @memberof Audit
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Audit
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof Audit
     */
    'author': string;
    /**
     * 
     * @type {User}
     * @memberof Audit
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface AuditList
 */
export interface AuditList {
    /**
     * 
     * @type {string}
     * @memberof AuditList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuditList
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof AuditList
     */
    'author': string;
}
/**
 * 
 * @export
 * @interface AuditRead
 */
export interface AuditRead {
    /**
     * 
     * @type {string}
     * @memberof AuditRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuditRead
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof AuditRead
     */
    'author': string;
}
/**
 * 
 * @export
 * @interface AuditUserRead
 */
export interface AuditUserRead {
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuditUserRead
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof AuditUserRead
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateApiKeyRequest
     */
    'scopes': Array<CreateApiKeyRequestScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'user': string;
}

export const CreateApiKeyRequestScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type CreateApiKeyRequestScopesEnum = typeof CreateApiKeyRequestScopesEnum[keyof typeof CreateApiKeyRequestScopesEnum];

/**
 * 
 * @export
 * @interface CreateDeviceRequest
 */
export interface CreateDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateDeviceRequest
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'public_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateDeviceRequest
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateDeviceRequest
     */
    'allowed_ips': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateGroupRequest
     */
    'scopes': Array<CreateGroupRequestScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof CreateGroupRequest
     */
    'rules': Array<CreateGroupRequestRulesInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateGroupRequest
     */
    'users'?: Array<string>;
}

export const CreateGroupRequestScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type CreateGroupRequestScopesEnum = typeof CreateGroupRequestScopesEnum[keyof typeof CreateGroupRequestScopesEnum];

/**
 * 
 * @export
 * @interface CreateGroupRequestRulesInner
 */
export interface CreateGroupRequestRulesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequestRulesInner
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequestRulesInner
     */
    'type': CreateGroupRequestRulesInnerTypeEnum;
}

export const CreateGroupRequestRulesInnerTypeEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type CreateGroupRequestRulesInnerTypeEnum = typeof CreateGroupRequestRulesInnerTypeEnum[keyof typeof CreateGroupRequestRulesInnerTypeEnum];

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'salt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'disabled_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'group': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    'devices'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateUserRequest
     */
    'keys'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    'audit'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Device
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'public_key': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'preshared_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Device
     */
    'allowed_ips': Array<string>;
    /**
     * 
     * @type {User}
     * @memberof Device
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface DeviceCreate
 */
export interface DeviceCreate {
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceCreate
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'public_key': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'preshared_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceCreate
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceCreate
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceCreate
     */
    'allowed_ips': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceList
 */
export interface DeviceList {
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceList
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'public_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceList
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceList
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceList
     */
    'allowed_ips': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceRead
 */
export interface DeviceRead {
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceRead
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'public_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRead
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceRead
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceRead
     */
    'allowed_ips': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceUpdate
 */
export interface DeviceUpdate {
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceUpdate
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'public_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceUpdate
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceUpdate
     */
    'allowed_ips': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceUserRead
 */
export interface DeviceUserRead {
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceUserRead
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceUserRead
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'scopes': Array<GroupScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof Group
     */
    'rules': Array<CreateGroupRequestRulesInner>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Group
     */
    'users'?: Array<User>;
}

export const GroupScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type GroupScopesEnum = typeof GroupScopesEnum[keyof typeof GroupScopesEnum];

/**
 * 
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    'scopes': Array<GroupCreateScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof GroupCreate
     */
    'rules': Array<CreateGroupRequestRulesInner>;
}

export const GroupCreateScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type GroupCreateScopesEnum = typeof GroupCreateScopesEnum[keyof typeof GroupCreateScopesEnum];

/**
 * 
 * @export
 * @interface GroupList
 */
export interface GroupList {
    /**
     * 
     * @type {string}
     * @memberof GroupList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupList
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupList
     */
    'scopes': Array<GroupListScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof GroupList
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof GroupList
     */
    'rules': Array<CreateGroupRequestRulesInner>;
}

export const GroupListScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type GroupListScopesEnum = typeof GroupListScopesEnum[keyof typeof GroupListScopesEnum];

/**
 * 
 * @export
 * @interface GroupRead
 */
export interface GroupRead {
    /**
     * 
     * @type {string}
     * @memberof GroupRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupRead
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupRead
     */
    'scopes': Array<GroupReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof GroupRead
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof GroupRead
     */
    'rules': Array<CreateGroupRequestRulesInner>;
}

export const GroupReadScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type GroupReadScopesEnum = typeof GroupReadScopesEnum[keyof typeof GroupReadScopesEnum];

/**
 * 
 * @export
 * @interface GroupUpdate
 */
export interface GroupUpdate {
    /**
     * 
     * @type {string}
     * @memberof GroupUpdate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUpdate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupUpdate
     */
    'scopes': Array<GroupUpdateScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof GroupUpdate
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof GroupUpdate
     */
    'rules': Array<CreateGroupRequestRulesInner>;
}

export const GroupUpdateScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type GroupUpdateScopesEnum = typeof GroupUpdateScopesEnum[keyof typeof GroupUpdateScopesEnum];

/**
 * 
 * @export
 * @interface GroupUsersList
 */
export interface GroupUsersList {
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupUsersList
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupUsersList
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface ListApiKey400Response
 */
export interface ListApiKey400Response {
    /**
     * 
     * @type {number}
     * @memberof ListApiKey400Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListApiKey400Response
     */
    'status': string;
    /**
     * 
     * @type {any}
     * @memberof ListApiKey400Response
     */
    'errors'?: any;
}
/**
 * 
 * @export
 * @interface Status200Response
 */
export interface Status200Response {
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'photo_url': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof Status200Response
     */
    'group': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Status200Response
     */
    'scopes': Array<Status200ResponseScopesEnum>;
}

export const Status200ResponseScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type Status200ResponseScopesEnum = typeof Status200ResponseScopesEnum[keyof typeof Status200ResponseScopesEnum];

/**
 * 
 * @export
 * @interface UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDeviceRequest
     */
    'dns'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDeviceRequest
     */
    'keep_alive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'endpoint'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDeviceRequest
     */
    'allowed_ips'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface UpdateGroupRequest
 */
export interface UpdateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'scopes'?: Array<UpdateGroupRequestScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'cidr'?: string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof UpdateGroupRequest
     */
    'rules'?: Array<CreateGroupRequestRulesInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'users'?: Array<string>;
}

export const UpdateGroupRequestScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type UpdateGroupRequestScopesEnum = typeof UpdateGroupRequestScopesEnum[keyof typeof UpdateGroupRequestScopesEnum];

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'salt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'disabled_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'group'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'devices'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateUserRequest
     */
    'keys'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'audit'?: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'disabled_reason'?: string;
    /**
     * 
     * @type {Group}
     * @memberof User
     */
    'group': Group;
    /**
     * 
     * @type {Array<Device>}
     * @memberof User
     */
    'devices'?: Array<Device>;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof User
     */
    'keys'?: Array<ApiKey>;
    /**
     * 
     * @type {Array<Audit>}
     * @memberof User
     */
    'audit'?: Array<Audit>;
}
/**
 * 
 * @export
 * @interface UserAuditList
 */
export interface UserAuditList {
    /**
     * 
     * @type {string}
     * @memberof UserAuditList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserAuditList
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof UserAuditList
     */
    'author': string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface UserDevicesList
 */
export interface UserDevicesList {
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDevicesList
     */
    'dns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'public_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDevicesList
     */
    'keep_alive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDevicesList
     */
    'endpoint': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDevicesList
     */
    'allowed_ips': Array<string>;
}
/**
 * 
 * @export
 * @interface UserGroupRead
 */
export interface UserGroupRead {
    /**
     * 
     * @type {string}
     * @memberof UserGroupRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserGroupRead
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserGroupRead
     */
    'scopes': Array<UserGroupReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserGroupRead
     */
    'cidr': string;
    /**
     * 
     * @type {Array<CreateGroupRequestRulesInner>}
     * @memberof UserGroupRead
     */
    'rules': Array<CreateGroupRequestRulesInner>;
}

export const UserGroupReadScopesEnum = {
    AdminUsersWrite: 'admin.users.write',
    AdminUsersReadonly: 'admin.users.readonly',
    AdminGroupsWrite: 'admin.groups.write',
    AdminGroupsReadonly: 'admin.groups.readonly',
    AdminDevicesWrite: 'admin.devices.write',
    AdminDevicesReadonly: 'admin.devices.readonly',
    AdminSettingsWrite: 'admin.settings.write',
    AdminSettingsReadonly: 'admin.settings.readonly',
    Admin: 'admin.*',
    UserDevicesWrite: 'user.devices.write',
    UserApikeyWrite: 'user.apikey.write',
    UserDevicesReadonly: 'user.devices.readonly',
    User: 'user.*'
} as const;

export type UserGroupReadScopesEnum = typeof UserGroupReadScopesEnum[keyof typeof UserGroupReadScopesEnum];

/**
 * 
 * @export
 * @interface UserKeysList
 */
export interface UserKeysList {
    /**
     * 
     * @type {number}
     * @memberof UserKeysList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserKeysList
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserKeysList
     */
    'scopes': Array<UserKeysListScopesEnum>;
}

export const UserKeysListScopesEnum = {
    User: 'user.*',
    Admin: 'admin.*'
} as const;

export type UserKeysListScopesEnum = typeof UserKeysListScopesEnum[keyof typeof UserKeysListScopesEnum];

/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserList
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'photo_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface UserpassLoginRequest
 */
export interface UserpassLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserpassLoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserpassLoginRequest
     */
    'password': string;
}

/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new ApiKey and persists it to storage.
         * @summary Create a new ApiKey
         * @param {CreateApiKeyRequest} createApiKeyRequest ApiKey to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (createApiKeyRequest: CreateApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApiKeyRequest' is not null or undefined
            assertParamExists('createApiKey', 'createApiKeyRequest', createApiKeyRequest)
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the ApiKey with the requested ID.
         * @summary Deletes a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApiKey', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ApiKeys.
         * @summary List ApiKeys
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKey: async (page?: number, itemsPerPage?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the ApiKey with the requested ID and returns it.
         * @summary Find a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApiKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readApiKey', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the attached User of the ApiKey with the given ID
         * @summary Find the attached User
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApiKeyUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readApiKeyUser', 'id', id)
            const localVarPath = `/api-keys/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new ApiKey and persists it to storage.
         * @summary Create a new ApiKey
         * @param {CreateApiKeyRequest} createApiKeyRequest ApiKey to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(createApiKeyRequest: CreateApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(createApiKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the ApiKey with the requested ID.
         * @summary Deletes a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ApiKeys.
         * @summary List ApiKeys
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKey(page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKey(page, itemsPerPage, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the ApiKey with the requested ID and returns it.
         * @summary Find a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readApiKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readApiKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the attached User of the ApiKey with the given ID
         * @summary Find the attached User
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readApiKeyUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readApiKeyUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeyApiFp(configuration)
    return {
        /**
         * Creates a new ApiKey and persists it to storage.
         * @summary Create a new ApiKey
         * @param {CreateApiKeyRequest} createApiKeyRequest ApiKey to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(createApiKeyRequest: CreateApiKeyRequest, options?: any): AxiosPromise<ApiKeyCreate> {
            return localVarFp.createApiKey(createApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the ApiKey with the requested ID.
         * @summary Deletes a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List ApiKeys.
         * @summary List ApiKeys
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKey(page?: number, itemsPerPage?: number, sort?: string, options?: any): AxiosPromise<Array<ApiKeyList>> {
            return localVarFp.listApiKey(page, itemsPerPage, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the ApiKey with the requested ID and returns it.
         * @summary Find a ApiKey by ID
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApiKey(id: number, options?: any): AxiosPromise<ApiKeyRead> {
            return localVarFp.readApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the attached User of the ApiKey with the given ID
         * @summary Find the attached User
         * @param {number} id ID of the ApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApiKeyUser(id: number, options?: any): AxiosPromise<ApiKeyUserRead> {
            return localVarFp.readApiKeyUser(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * Creates a new ApiKey and persists it to storage.
     * @summary Create a new ApiKey
     * @param {CreateApiKeyRequest} createApiKeyRequest ApiKey to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKey(createApiKeyRequest: CreateApiKeyRequest, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).createApiKey(createApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the ApiKey with the requested ID.
     * @summary Deletes a ApiKey by ID
     * @param {number} id ID of the ApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKey(id: number, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).deleteApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ApiKeys.
     * @summary List ApiKeys
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKey(page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).listApiKey(page, itemsPerPage, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the ApiKey with the requested ID and returns it.
     * @summary Find a ApiKey by ID
     * @param {number} id ID of the ApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public readApiKey(id: number, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).readApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the attached User of the ApiKey with the given ID
     * @summary Find the attached User
     * @param {number} id ID of the ApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public readApiKeyUser(id: number, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).readApiKeyUser(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuditApi - axios parameter creator
 * @export
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the Audit with the requested ID.
         * @summary Deletes a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudit: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAudit', 'id', id)
            const localVarPath = `/audits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Audits.
         * @summary List Audits
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [action] 
         * @param {string} [author] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudit: async (page?: number, itemsPerPage?: number, sort?: string, id?: string, action?: string, author?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/audits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the Audit with the requested ID and returns it.
         * @summary Find a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAudit: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readAudit', 'id', id)
            const localVarPath = `/audits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the attached User of the Audit with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuditUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readAuditUser', 'id', id)
            const localVarPath = `/audits/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 * @export
 */
export const AuditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the Audit with the requested ID.
         * @summary Deletes a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAudit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAudit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Audits.
         * @summary List Audits
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [action] 
         * @param {string} [author] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAudit(page?: number, itemsPerPage?: number, sort?: string, id?: string, action?: string, author?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAudit(page, itemsPerPage, sort, id, action, author, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the Audit with the requested ID and returns it.
         * @summary Find a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAudit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAudit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the attached User of the Audit with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAuditUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAuditUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditApi - factory interface
 * @export
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         * Deletes the Audit with the requested ID.
         * @summary Deletes a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudit(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAudit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Audits.
         * @summary List Audits
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [action] 
         * @param {string} [author] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudit(page?: number, itemsPerPage?: number, sort?: string, id?: string, action?: string, author?: string, options?: any): AxiosPromise<Array<AuditList>> {
            return localVarFp.listAudit(page, itemsPerPage, sort, id, action, author, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the Audit with the requested ID and returns it.
         * @summary Find a Audit by ID
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAudit(id: string, options?: any): AxiosPromise<AuditRead> {
            return localVarFp.readAudit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the attached User of the Audit with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuditUser(id: string, options?: any): AxiosPromise<AuditUserRead> {
            return localVarFp.readAuditUser(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditApi - object-oriented interface
 * @export
 * @class AuditApi
 * @extends {BaseAPI}
 */
export class AuditApi extends BaseAPI {
    /**
     * Deletes the Audit with the requested ID.
     * @summary Deletes a Audit by ID
     * @param {string} id ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public deleteAudit(id: string, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).deleteAudit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Audits.
     * @summary List Audits
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {string} [id] 
     * @param {string} [action] 
     * @param {string} [author] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public listAudit(page?: number, itemsPerPage?: number, sort?: string, id?: string, action?: string, author?: string, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).listAudit(page, itemsPerPage, sort, id, action, author, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the Audit with the requested ID and returns it.
     * @summary Find a Audit by ID
     * @param {string} id ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public readAudit(id: string, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).readAudit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the attached User of the Audit with the given ID
     * @summary Find the attached User
     * @param {string} id ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public readAuditUser(id: string, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).readAuditUser(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} sAMLResponse 
         * @param {string} relayState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthCallback: async (sAMLResponse: string, relayState: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sAMLResponse' is not null or undefined
            assertParamExists('googleAuthCallback', 'sAMLResponse', sAMLResponse)
            // verify required parameter 'relayState' is not null or undefined
            assertParamExists('googleAuthCallback', 'relayState', relayState)
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (sAMLResponse !== undefined) { 
                localVarFormParams.set('SAMLResponse', sAMLResponse as any);
            }
    
            if (relayState !== undefined) { 
                localVarFormParams.set('RelayState', relayState as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthStart: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronize users for the google provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthSync: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check authentication status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with a user and password
         * @param {UserpassLoginRequest} [userpassLoginRequest] Username and password to login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userpassLogin: async (userpassLoginRequest?: UserpassLoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/userpass/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userpassLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} sAMLResponse 
         * @param {string} relayState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleAuthCallback(sAMLResponse: string, relayState: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleAuthCallback(sAMLResponse, relayState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleAuthStart(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleAuthStart(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Synchronize users for the google provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleAuthSync(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleAuthSync(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check authentication status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login with a user and password
         * @param {UserpassLoginRequest} [userpassLoginRequest] Username and password to login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userpassLogin(userpassLoginRequest?: UserpassLoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userpassLogin(userpassLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} sAMLResponse 
         * @param {string} relayState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthCallback(sAMLResponse: string, relayState: string, options?: any): AxiosPromise<void> {
            return localVarFp.googleAuthCallback(sAMLResponse, relayState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthStart(options?: any): AxiosPromise<void> {
            return localVarFp.googleAuthStart(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Synchronize users for the google provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthSync(options?: any): AxiosPromise<void> {
            return localVarFp.googleAuthSync(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check authentication status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options?: any): AxiosPromise<Status200Response> {
            return localVarFp.status(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with a user and password
         * @param {UserpassLoginRequest} [userpassLoginRequest] Username and password to login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userpassLogin(userpassLoginRequest?: UserpassLoginRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userpassLogin(userpassLoginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} sAMLResponse 
     * @param {string} relayState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleAuthCallback(sAMLResponse: string, relayState: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleAuthCallback(sAMLResponse, relayState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleAuthStart(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleAuthStart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Synchronize users for the google provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleAuthSync(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleAuthSync(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check authentication status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public status(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).status(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with a user and password
     * @param {UserpassLoginRequest} [userpassLoginRequest] Username and password to login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userpassLogin(userpassLoginRequest?: UserpassLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userpassLogin(userpassLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Device and persists it to storage.
         * @summary Create a new Device
         * @param {CreateDeviceRequest} createDeviceRequest Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice: async (createDeviceRequest: CreateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDeviceRequest' is not null or undefined
            assertParamExists('createDevice', 'createDeviceRequest', createDeviceRequest)
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the Device with the requested ID.
         * @summary Deletes a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDevice', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Devices.
         * @summary List Devices
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [endpoint] 
         * @param {string} [allowedIps] 
         * @param {string} [publicKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevice: async (page?: number, itemsPerPage?: number, sort?: string, id?: string, user?: string, name?: string, type?: string, endpoint?: string, allowedIps?: string, publicKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }

            if (allowedIps !== undefined) {
                localVarQueryParameter['allowed_ips'] = allowedIps;
            }

            if (publicKey !== undefined) {
                localVarQueryParameter['public_key'] = publicKey;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the Device with the requested ID and returns it.
         * @summary Find a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDevice: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readDevice', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the attached User of the Device with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readDeviceUser', 'id', id)
            const localVarPath = `/devices/{id}/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Device and persists changes to storage.
         * @summary Updates a Device
         * @param {string} id ID of the Device
         * @param {UpdateDeviceRequest} updateDeviceRequest Device properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (id: string, updateDeviceRequest: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDevice', 'id', id)
            // verify required parameter 'updateDeviceRequest' is not null or undefined
            assertParamExists('updateDevice', 'updateDeviceRequest', updateDeviceRequest)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Device and persists it to storage.
         * @summary Create a new Device
         * @param {CreateDeviceRequest} createDeviceRequest Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDevice(createDeviceRequest: CreateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDevice(createDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the Device with the requested ID.
         * @summary Deletes a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Devices.
         * @summary List Devices
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [endpoint] 
         * @param {string} [allowedIps] 
         * @param {string} [publicKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDevice(page?: number, itemsPerPage?: number, sort?: string, id?: string, user?: string, name?: string, type?: string, endpoint?: string, allowedIps?: string, publicKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDevice(page, itemsPerPage, sort, id, user, name, type, endpoint, allowedIps, publicKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the Device with the requested ID and returns it.
         * @summary Find a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDevice(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the attached User of the Device with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDeviceUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDeviceUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Device and persists changes to storage.
         * @summary Updates a Device
         * @param {string} id ID of the Device
         * @param {UpdateDeviceRequest} updateDeviceRequest Device properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(id: string, updateDeviceRequest: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(id, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * Creates a new Device and persists it to storage.
         * @summary Create a new Device
         * @param {CreateDeviceRequest} createDeviceRequest Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice(createDeviceRequest: CreateDeviceRequest, options?: any): AxiosPromise<DeviceCreate> {
            return localVarFp.createDevice(createDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the Device with the requested ID.
         * @summary Deletes a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Devices.
         * @summary List Devices
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [endpoint] 
         * @param {string} [allowedIps] 
         * @param {string} [publicKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevice(page?: number, itemsPerPage?: number, sort?: string, id?: string, user?: string, name?: string, type?: string, endpoint?: string, allowedIps?: string, publicKey?: string, options?: any): AxiosPromise<Array<DeviceList>> {
            return localVarFp.listDevice(page, itemsPerPage, sort, id, user, name, type, endpoint, allowedIps, publicKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the Device with the requested ID and returns it.
         * @summary Find a Device by ID
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDevice(id: string, options?: any): AxiosPromise<DeviceRead> {
            return localVarFp.readDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the attached User of the Device with the given ID
         * @summary Find the attached User
         * @param {string} id ID of the Device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceUser(id: string, options?: any): AxiosPromise<DeviceUserRead> {
            return localVarFp.readDeviceUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Device and persists changes to storage.
         * @summary Updates a Device
         * @param {string} id ID of the Device
         * @param {UpdateDeviceRequest} updateDeviceRequest Device properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(id: string, updateDeviceRequest: UpdateDeviceRequest, options?: any): AxiosPromise<DeviceUpdate> {
            return localVarFp.updateDevice(id, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * Creates a new Device and persists it to storage.
     * @summary Create a new Device
     * @param {CreateDeviceRequest} createDeviceRequest Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public createDevice(createDeviceRequest: CreateDeviceRequest, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).createDevice(createDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the Device with the requested ID.
     * @summary Deletes a Device by ID
     * @param {string} id ID of the Device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deleteDevice(id: string, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deleteDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Devices.
     * @summary List Devices
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {string} [id] 
     * @param {string} [user] 
     * @param {string} [name] 
     * @param {string} [type] 
     * @param {string} [endpoint] 
     * @param {string} [allowedIps] 
     * @param {string} [publicKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public listDevice(page?: number, itemsPerPage?: number, sort?: string, id?: string, user?: string, name?: string, type?: string, endpoint?: string, allowedIps?: string, publicKey?: string, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).listDevice(page, itemsPerPage, sort, id, user, name, type, endpoint, allowedIps, publicKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the Device with the requested ID and returns it.
     * @summary Find a Device by ID
     * @param {string} id ID of the Device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public readDevice(id: string, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).readDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the attached User of the Device with the given ID
     * @summary Find the attached User
     * @param {string} id ID of the Device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public readDeviceUser(id: string, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).readDeviceUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Device and persists changes to storage.
     * @summary Updates a Device
     * @param {string} id ID of the Device
     * @param {UpdateDeviceRequest} updateDeviceRequest Device properties to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public updateDevice(id: string, updateDeviceRequest: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return DeviceApiFp(this.configuration).updateDevice(id, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Group and persists it to storage.
         * @summary Create a new Group
         * @param {CreateGroupRequest} createGroupRequest Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupRequest: CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupRequest' is not null or undefined
            assertParamExists('createGroup', 'createGroupRequest', createGroupRequest)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the Group with the requested ID.
         * @summary Deletes a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Groups.
         * @summary List Groups
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [scopes] 
         * @param {string} [cidr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (page?: number, itemsPerPage?: number, sort?: string, id?: string, name?: string, scopes?: string, cidr?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (scopes !== undefined) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List attached Users.
         * @summary List attached Users
         * @param {string} id ID of the Group
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupUsers: async (id: string, page?: number, itemsPerPage?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listGroupUsers', 'id', id)
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the Group with the requested ID and returns it.
         * @summary Find a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CookieAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Group and persists changes to storage.
         * @summary Updates a Group
         * @param {string} id ID of the Group
         * @param {UpdateGroupRequest} updateGroupRequest Group properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: string, updateGroupRequest: UpdateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            // verify required parameter 'updateGroupRequest' is not null or undefined
            assertParamExists('updateGroup', 'updateGroupRequest', updateGroupRequest)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Group and persists it to storage.
         * @summary Create a new Group
         * @param {CreateGroupRequest} createGroupRequest Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupRequest: CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the Group with the requested ID.
         * @summary Deletes a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Groups.
         * @summary List Groups
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [scopes] 
         * @param {string} [cidr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(page?: number, itemsPerPage?: number, sort?: string, id?: string, name?: string, scopes?: string, cidr?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(page, itemsPerPage, sort, id, name, scopes, cidr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List attached Users.
         * @summary List attached Users
         * @param {string} id ID of the Group
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupUsers(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupUsersList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupUsers(id, page, itemsPerPage, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the Group with the requested ID and returns it.
         * @summary Find a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Group and persists changes to storage.
         * @summary Updates a Group
         * @param {string} id ID of the Group
         * @param {UpdateGroupRequest} updateGroupRequest Group properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: string, updateGroupRequest: UpdateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, updateGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * Creates a new Group and persists it to storage.
         * @summary Create a new Group
         * @param {CreateGroupRequest} createGroupRequest Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupRequest: CreateGroupRequest, options?: any): AxiosPromise<GroupCreate> {
            return localVarFp.createGroup(createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the Group with the requested ID.
         * @summary Deletes a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Groups.
         * @summary List Groups
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [scopes] 
         * @param {string} [cidr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(page?: number, itemsPerPage?: number, sort?: string, id?: string, name?: string, scopes?: string, cidr?: string, options?: any): AxiosPromise<Array<GroupList>> {
            return localVarFp.listGroup(page, itemsPerPage, sort, id, name, scopes, cidr, options).then((request) => request(axios, basePath));
        },
        /**
         * List attached Users.
         * @summary List attached Users
         * @param {string} id ID of the Group
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupUsers(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: any): AxiosPromise<Array<GroupUsersList>> {
            return localVarFp.listGroupUsers(id, page, itemsPerPage, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the Group with the requested ID and returns it.
         * @summary Find a Group by ID
         * @param {string} id ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroup(id: string, options?: any): AxiosPromise<GroupRead> {
            return localVarFp.readGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Group and persists changes to storage.
         * @summary Updates a Group
         * @param {string} id ID of the Group
         * @param {UpdateGroupRequest} updateGroupRequest Group properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: string, updateGroupRequest: UpdateGroupRequest, options?: any): AxiosPromise<GroupUpdate> {
            return localVarFp.updateGroup(id, updateGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * Creates a new Group and persists it to storage.
     * @summary Create a new Group
     * @param {CreateGroupRequest} createGroupRequest Group to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(createGroupRequest: CreateGroupRequest, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).createGroup(createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the Group with the requested ID.
     * @summary Deletes a Group by ID
     * @param {string} id ID of the Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Groups.
     * @summary List Groups
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [scopes] 
     * @param {string} [cidr] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroup(page?: number, itemsPerPage?: number, sort?: string, id?: string, name?: string, scopes?: string, cidr?: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).listGroup(page, itemsPerPage, sort, id, name, scopes, cidr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List attached Users.
     * @summary List attached Users
     * @param {string} id ID of the Group
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroupUsers(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).listGroupUsers(id, page, itemsPerPage, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the Group with the requested ID and returns it.
     * @summary Find a Group by ID
     * @param {string} id ID of the Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public readGroup(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).readGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Group and persists changes to storage.
     * @summary Updates a Group
     * @param {string} id ID of the Group
     * @param {UpdateGroupRequest} updateGroupRequest Group properties to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(id: string, updateGroupRequest: UpdateGroupRequest, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(id, updateGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new User and persists it to storage.
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the User with the requested ID.
         * @summary Deletes a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Users.
         * @summary List Users
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [provider] 
         * @param {string} [email] 
         * @param {string} [disabled] 
         * @param {string} [disabledReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser: async (page?: number, itemsPerPage?: number, sort?: string, id?: string, firstname?: string, lastname?: string, provider?: string, email?: string, disabled?: string, disabledReason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (disabled !== undefined) {
                localVarQueryParameter['disabled'] = disabled;
            }

            if (disabledReason !== undefined) {
                localVarQueryParameter['disabled_reason'] = disabledReason;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List attached Audits.
         * @summary List attached Audits
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAudit: async (id: string, page?: number, itemsPerPage?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserAudit', 'id', id)
            const localVarPath = `/users/{id}/audit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List attached Devices.
         * @summary List attached Devices
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDevices: async (id: string, page?: number, itemsPerPage?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserDevices', 'id', id)
            const localVarPath = `/users/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List attached Keys.
         * @summary List attached Keys
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserKeys: async (id: string, page?: number, itemsPerPage?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserKeys', 'id', id)
            const localVarPath = `/users/{id}/keys`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page != null) {
                localVarHeaderParameter['x-page'] = typeof page === 'string'
                    ? page
                    : JSON.stringify(page);
            }

            if (itemsPerPage != null) {
                localVarHeaderParameter['x-items-per-page'] = typeof itemsPerPage === 'string'
                    ? itemsPerPage
                    : JSON.stringify(itemsPerPage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds the User with the requested ID and returns it.
         * @summary Find a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the attached Group of the User with the given ID
         * @summary Find the attached Group
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUserGroup', 'id', id)
            const localVarPath = `/users/{id}/group`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a User and persists changes to storage.
         * @summary Updates a User
         * @param {string} id ID of the User
         * @param {UpdateUserRequest} updateUserRequest User properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, updateUserRequest: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new User and persists it to storage.
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the User with the requested ID.
         * @summary Deletes a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Users.
         * @summary List Users
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [provider] 
         * @param {string} [email] 
         * @param {string} [disabled] 
         * @param {string} [disabledReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUser(page?: number, itemsPerPage?: number, sort?: string, id?: string, firstname?: string, lastname?: string, provider?: string, email?: string, disabled?: string, disabledReason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUser(page, itemsPerPage, sort, id, firstname, lastname, provider, email, disabled, disabledReason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List attached Audits.
         * @summary List attached Audits
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAudit(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAuditList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAudit(id, page, itemsPerPage, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List attached Devices.
         * @summary List attached Devices
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserDevices(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDevicesList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserDevices(id, page, itemsPerPage, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List attached Keys.
         * @summary List attached Keys
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserKeys(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserKeysList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserKeys(id, page, itemsPerPage, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds the User with the requested ID and returns it.
         * @summary Find a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the attached Group of the User with the given ID
         * @summary Find the attached Group
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a User and persists changes to storage.
         * @summary Updates a User
         * @param {string} id ID of the User
         * @param {UpdateUserRequest} updateUserRequest User properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Creates a new User and persists it to storage.
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<UserCreate> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the User with the requested ID.
         * @summary Deletes a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Users.
         * @summary List Users
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {string} [id] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [provider] 
         * @param {string} [email] 
         * @param {string} [disabled] 
         * @param {string} [disabledReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser(page?: number, itemsPerPage?: number, sort?: string, id?: string, firstname?: string, lastname?: string, provider?: string, email?: string, disabled?: string, disabledReason?: string, options?: any): AxiosPromise<Array<UserList>> {
            return localVarFp.listUser(page, itemsPerPage, sort, id, firstname, lastname, provider, email, disabled, disabledReason, options).then((request) => request(axios, basePath));
        },
        /**
         * List attached Audits.
         * @summary List attached Audits
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAudit(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: any): AxiosPromise<Array<UserAuditList>> {
            return localVarFp.listUserAudit(id, page, itemsPerPage, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List attached Devices.
         * @summary List attached Devices
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDevices(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: any): AxiosPromise<Array<UserDevicesList>> {
            return localVarFp.listUserDevices(id, page, itemsPerPage, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List attached Keys.
         * @summary List attached Keys
         * @param {string} id ID of the User
         * @param {number} [page] what page to render
         * @param {number} [itemsPerPage] item count to render per page
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserKeys(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: any): AxiosPromise<Array<UserKeysList>> {
            return localVarFp.listUserKeys(id, page, itemsPerPage, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds the User with the requested ID and returns it.
         * @summary Find a User by ID
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser(id: string, options?: any): AxiosPromise<UserRead> {
            return localVarFp.readUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the attached Group of the User with the given ID
         * @summary Find the attached Group
         * @param {string} id ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserGroup(id: string, options?: any): AxiosPromise<UserGroupRead> {
            return localVarFp.readUserGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a User and persists changes to storage.
         * @summary Updates a User
         * @param {string} id ID of the User
         * @param {UpdateUserRequest} updateUserRequest User properties to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Creates a new User and persists it to storage.
     * @summary Create a new User
     * @param {CreateUserRequest} createUserRequest User to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the User with the requested ID.
     * @summary Deletes a User by ID
     * @param {string} id ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Users.
     * @summary List Users
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {string} [id] 
     * @param {string} [firstname] 
     * @param {string} [lastname] 
     * @param {string} [provider] 
     * @param {string} [email] 
     * @param {string} [disabled] 
     * @param {string} [disabledReason] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUser(page?: number, itemsPerPage?: number, sort?: string, id?: string, firstname?: string, lastname?: string, provider?: string, email?: string, disabled?: string, disabledReason?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUser(page, itemsPerPage, sort, id, firstname, lastname, provider, email, disabled, disabledReason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List attached Audits.
     * @summary List attached Audits
     * @param {string} id ID of the User
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserAudit(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserAudit(id, page, itemsPerPage, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List attached Devices.
     * @summary List attached Devices
     * @param {string} id ID of the User
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserDevices(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserDevices(id, page, itemsPerPage, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List attached Keys.
     * @summary List attached Keys
     * @param {string} id ID of the User
     * @param {number} [page] what page to render
     * @param {number} [itemsPerPage] item count to render per page
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserKeys(id: string, page?: number, itemsPerPage?: number, sort?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listUserKeys(id, page, itemsPerPage, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds the User with the requested ID and returns it.
     * @summary Find a User by ID
     * @param {string} id ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public readUser(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).readUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the attached Group of the User with the given ID
     * @summary Find the attached Group
     * @param {string} id ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public readUserGroup(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).readUserGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a User and persists changes to storage.
     * @summary Updates a User
     * @param {string} id ID of the User
     * @param {UpdateUserRequest} updateUserRequest User properties to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



